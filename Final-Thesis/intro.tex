\section{Introduction}

A network's backbone is its routing control plane: a set of rules and distributed routing protocols that describe how the network should operate. A control plane is thus defined through configuration files present on every individual routing device in the network. These configurations are written in vendor specific languages (e.g. Cisco and Juniper) and describe very low level behaviours of a particular router. Network operators tasked to configure control planes are required to satisfy various `policies' that the owning organization wants to enforce: e.g certain devices should always be blocked from communicating with higher privileged devices.\\

Research has shown that configuring control planes can be extremely complex in modern networks~\cite{complexity}. Consequently, this causes configurations to be prone to errors, most of which are only uncovered during operation after a failure has already dealt significant damage~\cite{errors}.â€¯For example, in 2012, failure of a router in a Microsoft Azure data center triggered previously unknown configuration errors on other devices, degrading service in the West Europe region for over two hours~\cite{azure}. These examples highlight a need to develop highly resilient configurations that perform reliably.\\  

There are three main areas of research that are trying to enable this resilience: configuration synthesis, configuration development tools and network verification. Synthesis tools like NetComplete [CITE], Zeppelin [CITE] and SyNet [CITE] are working towards perhaps the most ambitious solution: automatically generating all configurations without the need of any writing. However, all synthesis tools require comprehensive input from the network operators. They usually have to fully specify the high level requirements of the policies the organization wishes to impose, ahead of time. This can be a time consuming and nuanced task for the operators. It is difficult to ascertain what existing policies the network follows and there is a lot of room to miss some rule or policy. Additionally, they may also be limited by the expressiveness of the language being used to describe the policies. This high-input nature of synthesis systems make them much more suitable during the initial stages of developing a network, given that the operators are willing to put in the work. However, the return rate of configuration synthesis falls sharply if the network operators are concerned with incremental changes. If there is a new router to be added to the network, the operators will need to reevaluate all policies in accordance of this new router. On top of that, the synthesis system will generate configurations for the entire network regardless of whether a router needs to be updated or not. This can make synthesis a unnecessarily resource wasteful process as all routers have to be updated, which may lead to more downtime in the network.\\ 

Network verification and repair (e.g ARC~\cite{arc}) can be extremely useful to determine whether the current configurations comply with the existing policies of the network. Again, these policies could be defined by the operators or, as in the case of ARC, they could be inferred via a snapshot of the network. However, verification by design is a post development tool i-e it will catch errors after they have already been produced. Between the time the tool is run and a fix is proposed, some damage might already be dealt. It does not help operators avoid producing these errors in the first place. We thus wish to provide a solution that sits in between configuration synthesis and verification. Our penultimate goal would be a "writing assistant" for network configurations, one that can complete entire stanzas (explained in section 2.1), automatically fill in parameters or even suggest more concise syntax. This paper establishes a concrete first step towards this goal: an engine for offering token completions.\\

% Connect these two paragraphs in a better wayyy

Currently, network operators try to minimize extraneous features by reusing existing configurations that have been known to work in the past. When creating a network, operators typically write templates containing specific configuration lines that define a base set of behaviours for different router roles~\cite{complexity}. These templates are then used to specialize individual routers to achieve objectives for their respective part of the network. Due to varying router specifications, the template systems used allow network operators to fill in parameters with appropriate information each time the template is used. Writing templates, however, can be an inefficient solution when dealing with special cases that deviate greatly from the predefined archetypal configurations. We thus propose a different approach that can serve to complement existing techniques for writing routing configurations.\\ 


We consider the problem of writing network configurations to be analogous to writing software code. Most configurations are written using vendor specific languages, that make use of rules and keywords similar to traditional programming languages. We envision an interactive system inspired by code completion engines that could be invoked by network operators as they are writing router configurations to offer them suggestions for what to put in next, or list the options available from the invocation point.\\ 

This paper outlines the necessary details for building a completion engine for network configurations. Section 2 provides background information about network configurations, existing network management tools and code completion techniques. Section 3 describes our token analysis results and explains how our model works. Section 4 discusses our plans for extending the model. Finally, Section 5 reviews all the work pertinent to our research, followed by a conclusion in Section 6.

\textbf{start background from here?}





Recent research on software systems has shown that codebases tend to contain regularities, much like natural languages~\cite{naturalness}. This has motivated further research on using traditional Natural Language Processing techniques for code completion and token suggestion, resulting in fairly accurate models~\cite{naturalness, raychev}. We hypothesize a similar regularity for network configurations, especially since they tend to be homogeneous by design, reusing the same set of keywords/tokens. Our analysis of router configurations from a large research university showed that configurations shared between 85\% and 99\% of tokens across different routers. This prompted us to explore simple NLP techniques that could leverage these token similarities to produce useful suggestions or completions. Our preliminary results show that using an off-the-shelf NLP algorithm with minor modifications, can give us up to 93\% accuracy for some configurations. These are encouraging results and in Section 4 we discuss many additional methodologies that we can apply to further improve these results.